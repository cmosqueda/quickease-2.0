import db_client from "../../utils/client";

/**
 * Retrieves all notes associated with a specific user.
 *
 * @param user_id - The unique identifier of the user whose notes are to be fetched.
 * @returns A promise that resolves to an array of notes belonging to the user.
 * @throws Will throw an error if the database query fails.
 */
export async function getUserNotes(user_id: string) {
  try {
    return await db_client.note.findMany({
      where: { user_id },
    });
  } catch (err) {
    throw err;
  }
}

/**
 * Retrieves a note belonging to a user by its unique identifier.
 *
 * @param note_id - The unique identifier of the note to retrieve.
 * @returns A promise that resolves to the note object if found, or `null` if not found.
 * @throws Will propagate any errors encountered during the database query.
 */
export async function getUserNote(note_id: string, user_id: string) {
  try {
    return await db_client.note.findFirst({
      where: {
        id: note_id,
        OR: [{ is_public: true }, { user_id: user_id }],
      },
      include: {
        user: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
            avatar: true,
          },
        },
        // Optional: Include connected items to verify creation in response
        flashcards: true,
        quizzes: true,
      },
    });
  } catch (err) {
    throw err;
  }
}
/**
 * Creates a new note for a user in the database.
 *
 * @param title - The title of the note.
 * @param content - The content of the note.
 * @param user_id - The ID of the user who owns the note.
 * @param is_ai_generated - Indicates whether the note was generated by AI.
 * @returns A promise that resolves to the created note object.
 * @throws Will throw an error if the note creation fails.
 */
export async function createUserNote(
  title: string,
  content: string,
  user_id: string,
  is_ai_generated: boolean,
  generatedQuiz?: { title: string; quiz_content: any } | null,
  generatedFlashcards?: { title: string; flashcards: any } | null
) {
  try {
    const noteData = {
      title,
      notes_content: content,
      user_id,
      is_ai_generated,
      is_public: true,
    };

    if (!generatedQuiz && !generatedFlashcards) {
      return await db_client.note.create({
        data: noteData,
      });
    }

    return await db_client.$transaction(
      async (tx) => {
        const note = await tx.note.create({
          data: { ...noteData, has_pregenerated_contents: true },
        });

        if (generatedQuiz) {
          await tx.quiz.create({
            data: {
              user_id,
              connected_note_id: note.id,
              title: generatedQuiz.title || `${title} - Quiz`,
              quiz_content: generatedQuiz.quiz_content,
              is_ai_generated: true,
              is_public: true,
            },
          });
        }

        if (generatedFlashcards) {
          await tx.flashcard.create({
            data: {
              user_id,
              connected_note_id: note.id,
              title: generatedFlashcards.title || `${title} - Flashcards`,
              flashcards: generatedFlashcards.flashcards,
              is_ai_generated: true,
              is_public: true,
            },
          });
        }

        return note;
      },
      {
        maxWait: 5000,
        timeout: 10000,
      }
    );
  } catch (err) {
    console.error("Note creation failed:", err);
    throw err;
  }
}
/**
 * Updates an existing user note with the provided title and content.
 *
 * @param title - The new title for the note.
 * @param content - The new content for the note.
 * @param note_id - The unique identifier of the note to update.
 * @returns A promise that resolves to the updated note object.
 * @throws Will throw an error if the update operation fails.
 */
export async function updateUserNote(
  title: string,
  content: string,
  note_id: string,
  user_id: string
) {
  const result = await db_client.note.updateMany({
    data: {
      title,
      notes_content: content,
    },
    where: {
      id: note_id,
      user_id: user_id,
    },
  });

  if (result.count === 0) {
    throw new Error("Note not found or user not authorized.");
  }

  return db_client.note.findUnique({ where: { id: note_id } });
}

/**
 * Deletes a user note from the database by its ID.
 *
 * @param note_id - The unique identifier of the note to be deleted.
 * @returns A promise that resolves to `true` if the note was successfully deleted.
 * @throws Will throw an error if the deletion fails.
 */
export async function deleteUserNote(note_id: string, user_id: string) {
  const result = await db_client.note.deleteMany({
    where: {
      id: note_id,
      user_id: user_id,
    },
  });

  if (result.count === 0) {
    throw new Error("Note not found or user not authorized.");
  }

  return true;
}

/**
 * Toggles the visibility of a note by updating its `is_public` status.
 *
 * @param visibility - The desired visibility state (`true` for public, `false` for private).
 * @param note_id - The unique identifier of the note to update.
 * @returns A promise that resolves to `true` if the update is successful.
 * @throws Will throw an error if the update operation fails.
 */
export async function toggleNoteVisibility(
  visibility: boolean,
  note_id: string,
  user_id: string
) {
  const result = await db_client.note.updateMany({
    data: { is_public: visibility },
    where: {
      id: note_id,
      user_id: user_id,
    },
  });

  if (result.count === 0) {
    throw new Error("Note not found or user not authorized.");
  }

  return db_client.note.findUnique({ where: { id: note_id } });
}
